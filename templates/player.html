<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Object Viewer</title>
    <link rel="stylesheet" href="/static/style.css" />
    <script src="/static/abrs/L2A.js"></script>
    <script src="/static/abrs/Latency.js"></script>
    <script src="/static/abrs/LoL+.js"></script>
</head>

<body>
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar" aria-label="Controls sidebar">
        <button class="toggle-button" onclick="toggleSidebar()" aria-label="Toggle sidebar">‚ò∞</button>

        <div class="options">
            <h3>Camera Parameters</h3>

            <label for="profile">Profile</label>
            <select id="profile">
                <option value="0" selected>0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
            </select>

            <label class="row">
                <span>Auto Quality (ABR)</span>
                <input type="checkbox" id="abr-enabled" checked />
            </label>

            <label for="abr-algo">ABR Algorithm</label>
            <select id="abr-algo">
                <option value="simple" selected>Simple (Latency)</option>
                <option value="l2a">L2A</option>
                <option value="lol+">LoL+</option>
            </select>

            <label for="resolution">Resolution</label>
            <select id="resolution">
                <option value="320x240">320x240</option>
                <option value="480x360">480x360</option>
                <option value="640x480">640x480</option>
                <option value="800x600" selected>800x600</option>
                <option value="1024x768">1024x768</option>
                <option value="1280x720">1280x720</option>
                <option value="1366x768">1366x768</option>
                <option value="1600x900">1600x900</option>
                <option value="1920x1080">1920x1080</option>
                <option value="2560x1440">2560x1440</option>
            </select>

            <div class="grid-2">
                <label for="cx">Principal X (cx)</label>
                <input type="number" id="cx" value="400" />
                <label for="cy">Principal Y (cy)</label>
                <input type="number" id="cy" value="300" />
            </div>

            <div class="grid-2">
                <label for="rot-step">Rotation Step (¬∞)</label>
                <input type="number" id="rot-step" value="1" step="0.1" />
                <label for="pos-step">Position Step</label>
                <input type="number" id="pos-step" value="0.1" step="0.01" />
            </div>

            <div class="grid-2">
                <label for="fx">Focal X (fx)</label>
                <input type="number" id="fx" value="1300" />
                <label for="fy">Focal Y (fy)</label>
                <input type="number" id="fy" value="800" />
            </div>

            <!-- Record -->
            <h3 class="section">Record</h3>
            <div class="card">
                <div class="btn-row">
                    <button id="start-rec" class="btn btn-danger">‚óè Start Recording</button>
                    <button id="stop-rec" class="btn" disabled>Stop &amp; Save</button>
                </div>
                <div id="rec-status" class="muted">Not recording</div>
            </div>

            <!-- Playback -->
            <h3 class="section">Playback</h3>
            <div class="card">
                <input type="file" id="rec-file" accept=".json" class="file-native">


                <div class="btn-row">
                    <button id="start-playback" class="btn btn-primary">Start</button>
                </div>

                <div class="progress" id="pb-wrap" hidden>
                    <div class="progress-bar" id="pb"></div>
                </div>
            </div>

        <div>
            <button class="apply-button" onclick="applyConfig()">Apply</button>
        </div>

        <h3 class="section">Save Images</h3>
        <div class="card">
        <label for="exp-name" class="muted" style="display:block; margin-bottom:6px;">Experiment name</label>
        <input id="exp-name" type="text" placeholder="e.g. lte_run_01" />

        <div class="btn-row" style="margin-top:10px;">
            <button id="save-images" class="btn btn-primary">Save Images</button>
        </div>

        <div id="save-images-status" class="muted" style="margin-top:8px;"></div>
        </div>
    </aside>

    <!-- Main -->
    <main class="main-content">
        <header class="topbar">
            <div class="brand">
                <span class="logo">üü¶</span>
                <span class="title">3D Object Viewer</span>
            </div>
            <div class="status">
                <span class="chip">Server render: <strong><span id="render-ms">‚Äì</span> ms</strong></span>
                <span class="chip secondary">Position: <strong id="position-display">Angle: 180¬∞, Elevation: 0¬∞, X: 0,
                        Y: 0, Z: 5</strong></span>
            </div>
        </header>

        <section class="stage">
            <div id="object-viewer" role="img" aria-label="Rendered 3D view">
                <p class="placeholder">Loading 3D object‚Ä¶</p>
            </div>

            <div class="hud">
                <div class="hud-row">
                    <span>Use Arrow keys to rotate, W/S for forward/back, A/D for left/right, Space/Shift for
                        up/down</span>
                </div>
            </div>
        </section>
    </main>

    <!-- Experiment Overlay -->
<div id="exp-overlay" class="exp-overlay hidden" role="dialog" aria-modal="true" aria-label="Experiment setup">
  <div class="exp-modal">
    <div class="exp-header">
      <h2>Experiment Setup</h2>
      <button id="exp-close" class="exp-x" aria-label="Close">‚úï</button>
    </div>

    <div class="exp-body">
      <div class="exp-grid">
        <label>
          <span>File name (experiment folder)</span>
          <input id="exp-fileName" type="text" placeholder="e.g. lte_run_01" />
        </label>

        <label>
          <span>Network name (for tc_status)</span>
          <input id="exp-networkName" type="text" placeholder="e.g. LTE_2min" />
        </label>

        <label>
          <span>Playback JSON</span>
          <input type="file" id="exp-playbackFile" accept=".json" />
        </label>

        <label>
          <span>Runs per ABR</span>
          <input id="exp-runsPerAbr" type="number" min="1" step="1" value="1" />
        </label>

        <label class="exp-row">
          <span>Disable manual input during run</span>
          <input id="exp-lockUI" type="checkbox" checked />
        </label>

        <label class="exp-row">
          <span>Auto export ZIP when finished</span>
          <input id="exp-autoExport" type="checkbox" />
        </label>
      </div>

      <div class="exp-status">
        <div><strong>Status:</strong> <span id="exp-statusText">Idle</span></div>
        <div class="exp-progress">
          <div class="exp-bar" id="exp-bar" style="width:0%"></div>
        </div>
        <div class="exp-small" id="exp-detailText"></div>
      </div>
    </div>

    <div class="exp-footer">
      <button id="exp-start" class="btn btn-primary">Start experiment</button>
      <button id="exp-cancel" class="btn" disabled>Cancel</button>
    </div>
  </div>
</div>

<button id="open-exp" class="btn btn-primary" style="position:fixed; right:16px; bottom:16px; z-index:20;">
  Run Experiment
</button>

    <script>
        // --- Minimal recorder state ---
        const REC = {
            active: false,
            startWall: 0,
            events: []
        };

        const btnStartRec = document.getElementById('start-rec');
        const btnStopRec = document.getElementById('stop-rec');

        btnStartRec.addEventListener('click', () => {
            REC.active = true;
            REC.startWall = performance.now();
            REC.events = [];
            btnStartRec.disabled = true;
            btnStopRec.disabled = false;
            console.log('[REC] started');
        });

        btnStopRec.addEventListener('click', () => {
            if (!REC.active) return;
            REC.active = false;
            btnStartRec.disabled = false;
            btnStopRec.disabled = true;

            // Download JSON
            const blob = new Blob([JSON.stringify(REC.events, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');

            const pad = (n) => String(n).padStart(2, '0');
            const d = new Date();
            const fname = `recording-${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.json`;

            a.href = url;
            a.download = fname;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            console.log(`[REC] saved ${REC.events.length} events`);
        });
    </script>
    <script>
        const ABRFactory = {
            create(kind, resSelect) {
                switch ((kind).toLowerCase()) {
                    case 'l2a': return new L2A_ABR(resSelect);
                    case 'lol+': return new LoLPlusABR(resSelect);
                    default: return new LatencyABR(resSelect);
                }
            }
        };

        const urlParams = new URLSearchParams(window.location.search);
        const modelId = urlParams.get("modelId"); // string or null

        const objectViewer = document.getElementById('object-viewer');
        const positionDisplay = document.getElementById('position-display');
        const sidebar = document.getElementById('sidebar');
        const resolutionSelect = document.getElementById('resolution');
        const abrToggle = document.getElementById('abr-enabled');
        const abrAlgoSelect = document.getElementById('abr-algo');

        let abr = ABRFactory.create(abrAlgoSelect.value, resolutionSelect);

        let angle = 180;
        let elevation = 0;
        let x = 0;
        let y = 0;
        let z = 5;

        // ACTIVE (applied) settings ‚Äî only changed by Apply
        let fx = 1300;
        let fy = 800;
        let cx = 400;
        let cy = 300;
        let width = 800;
        let height = 600;
        let rotStep = 1;
        let posStep = 0.1;
        let profileChoosen = 0;

        let abrEnabledActive = abrToggle.checked;

        let isLoading = false;
        const keysPressed = new Set();

        abrToggle.addEventListener('change', () => {

        });


        // Handle keyboard events
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 's', 'a', 'd', ' ', 'shift'].includes(key)) {
                event.preventDefault();
                keysPressed.add(key);
            }
        });

        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            keysPressed.delete(key);
        });

        function update() {
            requestAnimationFrame(update);
            if (isLoading || keysPressed.size === 0) return;

            let updated = false;
            const rad = angle * Math.PI / 180;
            const cosA = Math.cos(rad);
            const sinA = Math.sin(rad);

            // Rotations
            if (keysPressed.has('arrowup')) { elevation = Math.min(90, elevation + rotStep); updated = true; }
            if (keysPressed.has('arrowdown')) { elevation = Math.max(-90, elevation - rotStep); updated = true; }
            if (keysPressed.has('arrowleft')) { angle = (angle - rotStep + 360) % 360; updated = true; }
            if (keysPressed.has('arrowright')) { angle = (angle + rotStep) % 360; updated = true; }

            // Translations
            if (keysPressed.has('w')) { x += posStep * sinA; z += posStep * cosA; updated = true; }
            if (keysPressed.has('s')) { x -= posStep * sinA; z -= posStep * cosA; updated = true; }
            if (keysPressed.has('a')) { x -= posStep * cosA; z += posStep * sinA; updated = true; }
            if (keysPressed.has('d')) { x += posStep * cosA; z -= posStep * sinA; updated = true; }
            if (keysPressed.has('shift')) { y += posStep; updated = true; }
            if (keysPressed.has(' ')) { y -= posStep; updated = true; }

            if (updated) {
                positionDisplay.textContent = `Angle: ${angle.toFixed(0)}¬∞, Elevation: ${elevation.toFixed(0)}¬∞, X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}, Z: ${z.toFixed(1)}`;
                sendPosition().then(result => {
                    console.log("Image rendered", result);
                }).catch(err => {
                    console.error("Failed", err);
                });
            }
        }


        function applyConfig() {
            const [w, h] = resolutionSelect.value.split('x').map(Number);
            width = w;
            height = h;

            // Read camera + movement params
            fx = parseFloat(document.getElementById('fx').value);
            fy = parseFloat(document.getElementById('fy').value);
            cx = parseFloat(document.getElementById('cx').value);
            cy = parseFloat(document.getElementById('cy').value);
            rotStep = parseFloat(document.getElementById('rot-step').value);
            posStep = parseFloat(document.getElementById('pos-step').value);
            profileChoosen = document.getElementById('profile')?.value;


            // Commit ABR state from the checkbox
            abrEnabledActive = abrToggle.checked;
            abr = ABRFactory.create(abrAlgoSelect.value, resolutionSelect)

            cx = width / 2; cy = height / 2;
            document.getElementById('cx').value = cx;
            document.getElementById('cy').value = cy;
        }

        function toggleSidebar() {
            sidebar.classList.toggle('collapsed');
        }

        function sendPosition() {
            return new Promise((resolve, reject) => {
                isLoading = true;

                const abrEnabled = abrToggle.checked;
                let profile = 0;
                if (abrEnabled) {
                    profile = abr.pickProfile(width, height);   // decide for this request
                    abr.startRequest(profile, width, height);   // timestamp the request
                } else {
                    profile = profileChoosen;
                }

                const tFetchStart = performance.now();

                fetch('/render', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        modelId, angle, elevation, x, y, z, fx, fy, cx, cy, width, height, profile
                    }),
                })
                    .then(async (response) => {
                        const contentLength = Number(response.headers.get('Content-Length') || 0);
                        const renderHeader = response.headers.get('X-Render-Time-Ms');
                        renderMs = renderHeader != null ? parseFloat(renderHeader) : NaN;

                        const blob = await response.blob();
                        return { blob, contentLength, renderMs };
                    })
                    .then(({ blob, contentLength, renderMs }) => {
                        const imgUrl = URL.createObjectURL(blob);
                        const img = new Image();

                        img.onload = () => {
                            const displayW = Math.round(width);
                            const displayH = Math.round(height);

                            const rx = img.naturalWidth;
                            const ry = img.naturalHeight;

                            const scale = window.devicePixelRatio || 1;
                            const canvas = document.createElement('canvas');
                            canvas.width = displayW * scale;
                            canvas.height = displayH * scale;
                            canvas.style.width = displayW + 'px';
                            canvas.style.height = displayH + 'px';

                            const ctx = canvas.getContext('2d', { alpha: false });
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'low';
                            ctx.scale(scale, scale);

                            ctx.drawImage(img, 0, 0, rx, ry, 0, 0, displayW, displayH);

                            objectViewer.innerHTML = '';
                            objectViewer.appendChild(canvas);

                            isLoading = false;

                            if (abrEnabled) {
                                const bytes = contentLength || blob.size || 0;
                                abr.endRequest(bytes, rx, ry, renderMs);
                            }

                            if (typeof REC !== 'undefined' && REC.active) {
                                const tMs = Math.round(tFetchStart - REC.startWall);
                                const durationMs = Math.round(performance.now() - tFetchStart);
                                REC.events.push({
                                    tMs, durationMs,
                                    angle, elevation, x, y, z, fx, fy, cx, cy, width, height, profile
                                });
                            }

                            if (!Number.isNaN(renderMs)) {
                                const el = document.getElementById('render-ms');
                                if (el) el.textContent = renderMs.toFixed(2);
                            }

                            URL.revokeObjectURL(imgUrl);
                            resolve({ blob, renderMs, width, height, profile });
                        };

                        img.onerror = () => {
                            objectViewer.innerHTML = '<p>Error loading image</p>';
                            isLoading = false;
                            if (abrEnabled) abr.endRequest(0);
                            URL.revokeObjectURL(imgUrl);
                            reject(new Error("Image load failed"));
                        };

                        img.src = imgUrl;
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        objectViewer.innerHTML = '<p>Error loading image</p>';
                        isLoading = false;
                        if (abrEnabled) abr.endRequest(0);
                        reject(error);
                    });
            });
        }



        function updateImage() {
            sendPosition().then(result => {
                console.log("Image rendered", result);
            }).catch(err => {
                console.error("Failed", err);
            });
        }

        // Load initial image and start the loop
        updateImage();
        update();
    </script>
    <script>
        const fileInput = document.getElementById('rec-file');
        const startBtn = document.getElementById('start-playback');

        startBtn.addEventListener('click', async () => {
            const file = fileInput?.files?.[0];
            if (!file) { alert('Select a JSON file first.'); return; }

            try {
                startBtn.disabled = true;

                // --- Now start playback normally ---
                const text = await file.text();
                let events = JSON.parse(text);
                events = Array.isArray(events) ? events : (events.events || []);
                if (!events.length) throw new Error('No events in file');
                for (const ev of events) {
                    if (ev.angle != null) angle = Number(ev.angle);
                    if (ev.elevation != null) elevation = Number(ev.elevation);
                    if (ev.x != null) x = Number(ev.x);
                    if (ev.y != null) y = Number(ev.y);
                    if (ev.z != null) z = Number(ev.z);

                    positionDisplay.textContent = `Angle: ${angle.toFixed(0)}¬∞, Elevation: ${elevation.toFixed(0)}¬∞, X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}, Z: ${z.toFixed(1)}`;

                    await sendPosition();
                    const predictedBps = abr.lastThroughputBps;
                    const profileIdx = abr.profile;

                    console.log(predictedBps, profileIdx)

                    await reportPred(fileName, predictedBps, profileIdx, renderMs);
                }

            } catch (err) {
                console.error(err);
                alert('Playback failed: ' + err.message);
            } finally {
                startBtn.disabled = false;
            }
        });
    </script>

<script>
    // ---------------- Experiment Runner ----------------
    const overlay = document.getElementById('exp-overlay');
    const openExpBtn = document.getElementById('open-exp');
    const closeExpBtn = document.getElementById('exp-close');

    const expStartBtn = document.getElementById('exp-start');
    const expCancelBtn = document.getElementById('exp-cancel');

    const expStatusText = document.getElementById('exp-statusText');
    const expDetailText = document.getElementById('exp-detailText');
    const expBar = document.getElementById('exp-bar');

    const expFileName = document.getElementById('exp-fileName');
    const expNetworkName = document.getElementById('exp-networkName');
    const expPlaybackFile = document.getElementById('exp-playbackFile');
    const expRunsPerAbr = document.getElementById('exp-runsPerAbr');
    const expLockUI = document.getElementById('exp-lockUI');
    const expAutoExport = document.getElementById('exp-autoExport');

    let EXP_CANCEL = false;
    let EXP_RUNNING = false;

    function showOverlay() { 
        overlay.classList.remove('hidden'); 
    }
    function hideOverlay() { 
        if (!EXP_RUNNING) overlay.classList.add('hidden'); 
    }

    openExpBtn?.addEventListener('click', showOverlay);
    closeExpBtn?.addEventListener('click', hideOverlay);

    function setExpUI({running, status, detail, progress01}) {
        if (status != null) expStatusText.textContent = status;
        if (detail != null) expDetailText.textContent = detail;
        if (progress01 != null) expBar.style.width = `${Math.max(0, Math.min(1, progress01)) * 100}%`;

        EXP_RUNNING = !!running;
        expStartBtn.disabled = EXP_RUNNING;
        expCancelBtn.disabled = !EXP_RUNNING;
        closeExpBtn.disabled = EXP_RUNNING;
    }



    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function loadPlaybackEventsFromFile(file) {
        const text = await file.text();
        let events = JSON.parse(text);
        events = Array.isArray(events) ? events : (events.events || []);
        if (!events.length) throw new Error('No events in file');
        return events;
    }

    function setAbrKind(kind) {
        abrAlgoSelect.value = kind;
        abr = ABRFactory.create(kind, resolutionSelect);
    }

    async function runOnePlayback(events) {
        for (const ev of events) {
            if (EXP_CANCEL) throw new Error('CANCELLED');

            if (ev.angle != null) angle = Number(ev.angle);
            if (ev.elevation != null) elevation = Number(ev.elevation);
            if (ev.x != null) x = Number(ev.x);
            if (ev.y != null) y = Number(ev.y);
            if (ev.z != null) z = Number(ev.z);

            positionDisplay.textContent =
                `Angle: ${angle.toFixed(0)}¬∞, Elevation: ${elevation.toFixed(0)}¬∞, X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}, Z: ${z.toFixed(1)}`;

            await sendPosition();

            const predictedBps = abr.lastThroughputBps;
            const profileIdx = abr.profile;
            const networkName = expNetworkName.value;

            await reportPred(networkName, fileName, predictedBps, profileIdx, renderMs);
            await saveMovement(fileName, modelId, angle, elevation, x, y, z, fx, fy, cx, cy, width, height, profileIdx)
        }
    }

    async function reportPred(networkName, fileName, pred_bps, profile, renderMs) {
        try {
        await fetch("/metrics/predict", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            cache: "no-store",
            body: JSON.stringify({
            networkName,
            fileName,
            pred_bps,
            profile,
            renderMs: renderMs
            })
        });
        } catch (e) {
            console.warn("[predict] post failed", e);
        }
    }
    async function saveMovement(filename, modelId, angle, elevation, x, y, z, fx, fy, cx, cy, width, height, profile) {
        try {
        await fetch("/movement", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            cache: "no-store",
            body: JSON.stringify({
                fileName,
                modelId,
                angle,
                elevation,
                x,
                y,
                z,
                fx,
                fy,
                cx,
                cy,
                width,
                height,
                profile
            })
        });
        } catch (e) {
            console.warn("[predict] post failed", e);
        }
    }

    async function runExperimentSequentialABRs({events, runsPerAbr, lockUI, autoExport}) {
        const abrOrder = ['simple', 'l2a', 'lol+'];

        const totalRuns = abrOrder.length * runsPerAbr;
        let doneRuns = 0;

        setExpUI({running:true, status:"Running", detail:"Preparing‚Ä¶", progress01:0});
        EXP_CANCEL = false;

        abrToggle.checked = true;

        for (const abrKind of abrOrder) {
        for (let r = 1; r <= runsPerAbr; r++) {
            if (EXP_CANCEL) throw new Error('CANCELLED');

            fileName = `${expFileName.value}__${abrKind}__run${r}`;

            setAbrKind(abrKind);

            // Optional: reset ABR internal state between runs, if your ABR classes support it
            // (safer for reproducibility)
            if (typeof abr.reset === 'function') abr.reset();

            setExpUI({
            running:true,
            status:"Running",
            detail:`ABR=${abrKind} (run ${r}/${runsPerAbr}) ‚Üí folder: ${fileName}`,
            progress01: doneRuns / totalRuns
            });

            await runOnePlayback(events);

            doneRuns++;
            setExpUI({running:true, progress01: doneRuns / totalRuns});

            await sleep(150);
        }
        }

        setExpUI({running:false, status:"Finished", detail:"All ABRs completed.", progress01:1});


        if (autoExport) {
            const base = document.getElementById('exp-fileName')?.value?.trim();
            if (base) window.open(`/export?fileName=${encodeURIComponent(base)}`, '_blank');
        }
    }

    expCancelBtn.addEventListener('click', () => {
        EXP_CANCEL = true;
        setExpUI({running:true, status:"Stopping‚Ä¶", detail:"Cancelling after current request‚Ä¶"});
    });

    expStartBtn.addEventListener('click', async () => {
        try {
        // Gather values from overlay and apply to your active variables.
        const baseName = (expFileName.value || '').trim();
        if (!baseName) { alert("Please enter a file name."); return; }

        const net = (expNetworkName.value || '').trim();
        if (!net) { alert("Please enter a network name."); return; }

        const pbFile = expPlaybackFile.files?.[0];
        if (!pbFile) { alert("Please select a playback JSON."); return; }

        const runsPerAbr = Math.max(1, parseInt(expRunsPerAbr.value || '1', 10));

        const events = await loadPlaybackEventsFromFile(pbFile);

        await runExperimentSequentialABRs({
            events,
            runsPerAbr,
            lockUI: !!expLockUI.checked,
            autoExport: !!expAutoExport.checked
        });

        } catch (err) {
        if (String(err?.message || err).includes('CANCELLED')) {
            setExpUI({running:false, status:"Cancelled", detail:"Experiment cancelled.", progress01:0});
        } else {
            console.error(err);
            setExpUI({running:false, status:"Error", detail:String(err?.message || err), progress01:0});
            alert('Experiment failed: ' + (err?.message || err));
        } 
        }
    });

    // Initial state
    setExpUI({running:false, status:"Idle", detail:"Configure settings and press Start.", progress01:0});
</script>

<script>
  const saveImagesBtn = document.getElementById('save-images');
  const expNameInput = document.getElementById('exp-name');
  const saveImagesStatus = document.getElementById('save-images-status');

  saveImagesBtn?.addEventListener('click', async () => {
    const experimentName = (expNameInput?.value || '').trim();
    if (!experimentName) {
      alert('Please enter an experiment name.');
      expNameInput?.focus();
      return;
    }

    saveImagesBtn.disabled = true;
    if (saveImagesStatus) saveImagesStatus.textContent = 'Sending request‚Ä¶';

    try {
      const res = await fetch('/saveImages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        cache: 'no-store',
        body: JSON.stringify({ experimentName })
      });

      if (!res.ok) {
        const txt = await res.text().catch(() => '');
        throw new Error(txt || `HTTP ${res.status}`);
      }

      // If backend returns JSON, you can read it; if not, ignore.
      // const data = await res.json().catch(() => null);

      if (saveImagesStatus) saveImagesStatus.textContent = `‚úÖ Saved images for "${experimentName}"`;
    } catch (e) {
      console.error('[saveImages] failed', e);
      if (saveImagesStatus) saveImagesStatus.textContent = `‚ùå Failed: ${e.message || e}`;
      alert('Save Images failed: ' + (e.message || e));
    } finally {
      saveImagesBtn.disabled = false;
    }
  });
</script>

</body>

</html>