<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Object Viewer</title>
    <link rel="stylesheet" href="/static/style.css" />
    <script src="/static/abrs/L2A.js"></script>
    <script src="/static/abrs/Latency.js"></script>
    <script src="/static/abrs/LoL+.js"></script>
</head>

<body>
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar" aria-label="Controls sidebar">
        <button class="toggle-button" onclick="toggleSidebar()" aria-label="Toggle sidebar">‚ò∞</button>

        <div class="options">
            <h3>Camera Parameters</h3>

            <label class="row">
                <span>Auto Quality (ABR)</span>
                <input type="checkbox" id="abr-enabled" checked />
            </label>

            <label for="abr-algo">ABR Algorithm</label>
            <select id="abr-algo">
                <option value="simple" selected>Simple (Latency)</option>
                <option value="l2a">L2A</option>
                <option value="lol+">LoL+</option>
            </select>

            <label for="resolution">Resolution</label>
            <select id="resolution">
                <option value="320x240">320x240</option>
                <option value="480x360">480x360</option>
                <option value="640x480">640x480</option>
                <option value="800x600" selected>800x600</option>
                <option value="1024x768">1024x768</option>
                <option value="1280x720">1280x720</option>
                <option value="1366x768">1366x768</option>
                <option value="1600x900">1600x900</option>
                <option value="1920x1080">1920x1080</option>
                <option value="2560x1440">2560x1440</option>
            </select>

            <div class="grid-2">
                <label for="cx">Principal X (cx)</label>
                <input type="number" id="cx" value="400" />
                <label for="cy">Principal Y (cy)</label>
                <input type="number" id="cy" value="300" />
            </div>

            <div class="grid-2">
                <label for="rot-step">Rotation Step (¬∞)</label>
                <input type="number" id="rot-step" value="1" step="0.1" />
                <label for="pos-step">Position Step</label>
                <input type="number" id="pos-step" value="0.1" step="0.01" />
            </div>

            <div class="grid-2">
                <label for="fx">Focal X (fx)</label>
                <input type="number" id="fx" value="1300" />
                <label for="fy">Focal Y (fy)</label>
                <input type="number" id="fy" value="800" />
            </div>

            <!-- Record -->
            <h3 class="section">Record</h3>
            <div class="card">
                <div class="btn-row">
                    <button id="start-rec" class="btn btn-danger">‚óè Start Recording</button>
                    <button id="stop-rec" class="btn" disabled>Stop &amp; Save</button>
                </div>
                <div id="rec-status" class="muted">Not recording</div>
            </div>

            <!-- Playback -->
            <h3 class="section">Playback</h3>
            <div class="card">
                <input type="file" id="rec-file" accept=".json" class="file-native">


                <div class="btn-row">
                    <button id="start-playback" class="btn btn-primary">Start</button>
                </div>

                <div class="progress" id="pb-wrap" hidden>
                    <div class="progress-bar" id="pb"></div>
                </div>
            </div>

            <button class="apply-button" onclick="applyConfig()">Apply</button>
        </div>
    </aside>

    <!-- Main -->
    <main class="main-content">
        <header class="topbar">
            <div class="brand">
                <span class="logo">üü¶</span>
                <span class="title">3D Object Viewer</span>
            </div>
            <div class="status">
                <span class="chip">Server render: <strong><span id="render-ms">‚Äì</span> ms</strong></span>
                <span class="chip secondary">Position: <strong id="position-display">Angle: 180¬∞, Elevation: 0¬∞, X: 0,
                        Y: 0, Z: 5</strong></span>
            </div>
        </header>

        <section class="stage">
            <div id="object-viewer" role="img" aria-label="Rendered 3D view">
                <p class="placeholder">Loading 3D object‚Ä¶</p>
            </div>

            <div class="hud">
                <div class="hud-row">
                    <span>Use Arrow keys to rotate, W/S for forward/back, A/D for left/right, Space/Shift for
                        up/down</span>
                </div>
            </div>
        </section>
    </main>
    <script>
        // --- Minimal recorder state ---
        const REC = {
            active: false,
            startWall: 0,
            events: []
        };

        const btnStartRec = document.getElementById('start-rec');
        const btnStopRec = document.getElementById('stop-rec');

        btnStartRec.addEventListener('click', () => {
            REC.active = true;
            REC.startWall = performance.now();
            REC.events = [];
            btnStartRec.disabled = true;
            btnStopRec.disabled = false;
            console.log('[REC] started');
        });

        btnStopRec.addEventListener('click', () => {
            if (!REC.active) return;
            REC.active = false;
            btnStartRec.disabled = false;
            btnStopRec.disabled = true;

            // Download JSON
            const blob = new Blob([JSON.stringify(REC.events, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');

            const pad = (n) => String(n).padStart(2, '0');
            const d = new Date();
            const fname = `recording-${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.json`;

            a.href = url;
            a.download = fname;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            console.log(`[REC] saved ${REC.events.length} events`);
        });
    </script>
    <script>
        const ABRFactory = {
            create(kind, resSelect) {
                switch ((kind).toLowerCase()) {
                    case 'l2a': return new L2A_ABR(resSelect);
                    case 'lol+': return new LoLPlusABR(resSelect);
                    default: return new LatencyABR(resSelect);
                }
            }
        };

        const objectViewer = document.getElementById('object-viewer');
        const positionDisplay = document.getElementById('position-display');
        const sidebar = document.getElementById('sidebar');
        const resolutionSelect = document.getElementById('resolution');
        const abrToggle = document.getElementById('abr-enabled');
        const abrAlgoSelect = document.getElementById('abr-algo');

        let abr = ABRFactory.create(abrAlgoSelect.value, resolutionSelect);

        let angle = 180;
        let elevation = 0;
        let x = 0;
        let y = 0;
        let z = 5;

        // ACTIVE (applied) settings ‚Äî only changed by Apply
        let fx = 1300;
        let fy = 800;
        let cx = 400;
        let cy = 300;
        let width = 800;
        let height = 600;
        let rotStep = 1;
        let posStep = 0.1;

        let abrEnabledActive = abrToggle.checked;

        let isLoading = false;
        const keysPressed = new Set();

        abrToggle.addEventListener('change', () => {

        });


        // Handle keyboard events
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 's', 'a', 'd', ' ', 'shift'].includes(key)) {
                event.preventDefault();
                keysPressed.add(key);
            }
        });

        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            keysPressed.delete(key);
        });

        function update() {
            requestAnimationFrame(update);
            if (isLoading || keysPressed.size === 0) return;

            let updated = false;
            const rad = angle * Math.PI / 180;
            const cosA = Math.cos(rad);
            const sinA = Math.sin(rad);

            // Rotations
            if (keysPressed.has('arrowup')) { elevation = Math.min(90, elevation + rotStep); updated = true; }
            if (keysPressed.has('arrowdown')) { elevation = Math.max(-90, elevation - rotStep); updated = true; }
            if (keysPressed.has('arrowleft')) { angle = (angle - rotStep + 360) % 360; updated = true; }
            if (keysPressed.has('arrowright')) { angle = (angle + rotStep) % 360; updated = true; }

            // Translations
            if (keysPressed.has('w')) { x += posStep * sinA; z += posStep * cosA; updated = true; }
            if (keysPressed.has('s')) { x -= posStep * sinA; z -= posStep * cosA; updated = true; }
            if (keysPressed.has('a')) { x -= posStep * cosA; z += posStep * sinA; updated = true; }
            if (keysPressed.has('d')) { x += posStep * cosA; z -= posStep * sinA; updated = true; }
            if (keysPressed.has('shift')) { y += posStep; updated = true; }
            if (keysPressed.has(' ')) { y -= posStep; updated = true; }

            if (updated) {
                positionDisplay.textContent = `Angle: ${angle.toFixed(0)}¬∞, Elevation: ${elevation.toFixed(0)}¬∞, X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}, Z: ${z.toFixed(1)}`;
                sendPosition().then(result => {
                    console.log("Image rendered", result);
                }).catch(err => {
                    console.error("Failed", err);
                });
            }
        }


        function applyConfig() {
            const [w, h] = resolutionSelect.value.split('x').map(Number);
            width = w;
            height = h;

            // Read camera + movement params
            fx = parseFloat(document.getElementById('fx').value);
            fy = parseFloat(document.getElementById('fy').value);
            cx = parseFloat(document.getElementById('cx').value);
            cy = parseFloat(document.getElementById('cy').value);
            rotStep = parseFloat(document.getElementById('rot-step').value);
            posStep = parseFloat(document.getElementById('pos-step').value);

            // Commit ABR state from the checkbox
            abrEnabledActive = abrToggle.checked;
            abr = ABRFactory.create(abrAlgoSelect.value, resolutionSelect)

            cx = width / 2; cy = height / 2;
            document.getElementById('cx').value = cx;
            document.getElementById('cy').value = cy;

            sendPosition().then(result => {
                console.log("Image rendered", result);
            }).catch(err => {
                console.error("Failed", err);
            });
        }

        function toggleSidebar() {
            sidebar.classList.toggle('collapsed');
        }

        function sendPosition() {
            return new Promise((resolve, reject) => {
                isLoading = true;

                const abrEnabled = abrToggle.checked;
                let profile = 0;
                if (abrEnabled) {
                    profile = abr.pickProfile(width, height);   // decide for this request
                    abr.startRequest(profile, width, height);   // timestamp the request
                }

                const tFetchStart = performance.now();

                fetch('/render', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        angle, elevation, x, y, z, fx, fy, cx, cy, width, height, profile
                    }),
                })
                    .then(async (response) => {
                        const contentLength = Number(response.headers.get('Content-Length') || 0);
                        const renderHeader = response.headers.get('X-Render-Time-Ms');
                        const renderMs = renderHeader != null ? parseFloat(renderHeader) : NaN;

                        const blob = await response.blob();
                        return { blob, contentLength, renderMs };
                    })
                    .then(({ blob, contentLength, renderMs }) => {
                        const imgUrl = URL.createObjectURL(blob);
                        const img = new Image();

                        img.onload = () => {
                            const displayW = Math.round(width);
                            const displayH = Math.round(height);

                            const rx = img.naturalWidth;
                            const ry = img.naturalHeight;

                            const scale = window.devicePixelRatio || 1;
                            const canvas = document.createElement('canvas');
                            canvas.width = displayW * scale;
                            canvas.height = displayH * scale;
                            canvas.style.width = displayW + 'px';
                            canvas.style.height = displayH + 'px';

                            const ctx = canvas.getContext('2d', { alpha: false });
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            ctx.scale(scale, scale);

                            ctx.drawImage(img, 0, 0, rx, ry, 0, 0, displayW, displayH);

                            objectViewer.innerHTML = '';
                            objectViewer.appendChild(canvas);

                            isLoading = false;

                            if (abrEnabled) {
                                const bytes = contentLength || blob.size || 0;
                                abr.endRequest(bytes, rx, ry, renderMs);
                            }

                            if (typeof REC !== 'undefined' && REC.active) {
                                const tMs = Math.round(tFetchStart - REC.startWall);
                                const durationMs = Math.round(performance.now() - tFetchStart);
                                REC.events.push({
                                    tMs, durationMs,
                                    angle, elevation, x, y, z, fx, fy, cx, cy, width, height, profile
                                });
                            }

                            if (!Number.isNaN(renderMs)) {
                                const el = document.getElementById('render-ms');
                                if (el) el.textContent = renderMs.toFixed(2);
                            }

                            URL.revokeObjectURL(imgUrl);
                            resolve({ blob, renderMs, width, height, profile });
                        };

                        img.onerror = () => {
                            objectViewer.innerHTML = '<p>Error loading image</p>';
                            isLoading = false;
                            if (abrEnabled) abr.endRequest(0);
                            URL.revokeObjectURL(imgUrl);
                            reject(new Error("Image load failed"));
                        };

                        img.src = imgUrl;
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        objectViewer.innerHTML = '<p>Error loading image</p>';
                        isLoading = false;
                        if (abrEnabled) abr.endRequest(0);
                        reject(error);
                    });
            });
        }



        function updateImage() {
            sendPosition().then(result => {
                console.log("Image rendered", result);
            }).catch(err => {
                console.error("Failed", err);
            });
        }

        // Load initial image and start the loop
        updateImage();
        update();
    </script>
    <script>
        const fileInput = document.getElementById('rec-file');
        const startBtn = document.getElementById('start-playback');

        async function reportPred(id, pred_bps, profile) {
            try {
                await fetch("/metrics/predict", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    cache: "no-store",
                    body: JSON.stringify({
                        expId: id,
                        pred_bps,
                        profile
                    })
                });
            } catch (e) {
                console.warn("[predict] post failed", e);
            }
        }

        // Helper: wait until absolute timestamp
        async function waitUntil(startAt) {
            let delay = startAt - Date.now();
            if (delay > 0) {
                console.log(`[playback] Waiting ${delay} ms until start...`);
                return new Promise(resolve => setTimeout(resolve, delay));
            }
        }

        startBtn.addEventListener('click', async () => {
            const file = fileInput?.files?.[0];
            if (!file) { alert('Select a JSON file first.'); return; }

            try {
                startBtn.disabled = true;

                // 1. Pick a timestamp a few seconds in the future
                const startAt = Date.now() + 5000;

                // 2. Tell the server to wait and launch bandwidth script at that timestamp
                await fetch("/playback/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ startAt })
                });

                // 3. Locally wait until the same timestamp
                await waitUntil(startAt);
                console.log("[playback] START at", new Date().toISOString());

                // --- Now start playback normally ---
                const text = await file.text();
                let events = JSON.parse(text);
                events = Array.isArray(events) ? events : (events.events || []);
                if (!events.length) throw new Error('No events in file');
                let id = 0;
                for (const ev of events) {
                    if (ev.angle != null) angle = Number(ev.angle);
                    if (ev.elevation != null) elevation = Number(ev.elevation);
                    if (ev.x != null) x = Number(ev.x);
                    if (ev.y != null) y = Number(ev.y);
                    if (ev.z != null) z = Number(ev.z);

                    positionDisplay.textContent = `Angle: ${angle.toFixed(0)}¬∞, Elevation: ${elevation.toFixed(0)}¬∞, X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}, Z: ${z.toFixed(1)}`;

                    await sendPosition();
                    //const predictedBps = abr.lastThroughputBps;
                    //const profileIdx = abr.profile;

                    //await reportPred(id, predictedBps, profileIdx);

                }

            } catch (err) {
                console.error(err);
                alert('Playback failed: ' + err.message);
            } finally {
                startBtn.disabled = false;
            }
        });
    </script>
</body>

</html>