<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Object Viewer</title>
    <link rel="stylesheet" href="/static/style.css" />
    <script src="/static/abrs/L2A.js"></script>
    <script src="/static/abrs/Latency.js"></script>
    <script src="/static/abrs/LoL+.js"></script>
</head>

<body>
    <div class="sidebar" id="sidebar">
        <button class="toggle-button" onclick="toggleSidebar()">☰</button>
        <div class="options">
            <h3>Camera Parameters</h3>

            <label>Auto Quality (ABR)</label>
            <input type="checkbox" id="abr-enabled" checked />

            <label>ABR Algorithm:</label>
            <select id="abr-algo">
                <option value="simple" selected>Simple (Latency)</option>
                <option value="l2a">L2A</option>
                <option value="lol+">LoL+</option>
            </select>

            <label>Resolution:</label>
            <select id="resolution">
                <option value="320x240">320x240</option>
                <option value="480x360">480x360</option>
                <option value="640x480">640x480</option>
                <option value="800x600" selected>800x600</option>
                <option value="1024x768">1024x768</option>
                <option value="1280x720">1280x720</option>
                <option value="1366x768">1366x768</option>
                <option value="1600x900">1600x900</option>
                <option value="1920x1080">1920x1080</option>
                <option value="2560x1440">2560x1440</option>
            </select><br />

            <label>Principal Point X (cx):</label>
            <input type="number" id="cx" value="400" /><br />
            <label>Principal Point Y (cy):</label>
            <input type="number" id="cy" value="300" /><br />

            <label>Rotation Step (°):</label>
            <input type="number" id="rot-step" value="1" step="0.1" /><br />
            <label>Position Step:</label>
            <input type="number" id="pos-step" value="0.1" step="0.01" /><br />

            <label>Focal Length X (fx):</label>
            <input type="number" id="fx" value="1300" /><br />
            <label>Focal Length Y (fy):</label>
            <input type="number" id="fy" value="800" /><br />

            <button class="apply-button" onclick="applyConfig()">Apply</button>
        </div>
    </div>

    <div class="main-content">
        <div class="container">
            <div id="object-viewer">
                <p>Loading 3D object...</p>
            </div>
            <div class="instructions">
                <p>
                    Current position:
                    <span id="position-display">Angle: 180°, Elevation: 0°, X: 0, Y: 0, Z: 5</span>
                </p>
                <p>Use Arrow keys to rotate, W/S for forward/back, A/D for left/right, Space/Shift for up/down</p>
                <p>Server render time: <span id="render-ms">–</span> ms</p>
            </div>
        </div>
    </div>

    <script>
        const ABRFactory = {
            create(kind, resSelect) {
                switch ((kind).toLowerCase()) {
                    case 'l2a': return new L2A_ABR(resSelect);
                    case 'lol+': return new LoLPlusABR(resSelect);
                    default: return new LatencyABR(resSelect);
                }
            }
        };

        const objectViewer = document.getElementById('object-viewer');
        const positionDisplay = document.getElementById('position-display');
        const sidebar = document.getElementById('sidebar');
        const resolutionSelect = document.getElementById('resolution');
        const abrToggle = document.getElementById('abr-enabled');
        const abrAlgoSelect = document.getElementById('abr-algo');

        let abr = ABRFactory.create(abrAlgoSelect.value, resolutionSelect);

        let angle = 180;
        let elevation = 0;
        let x = 0;
        let y = 0;
        let z = 5;

        // ACTIVE (applied) settings — only changed by Apply
        let fx = 1300;
        let fy = 800;
        let cx = 400;
        let cy = 300;
        let width = 800;
        let height = 600;
        let rotStep = 1;
        let posStep = 0.1;

        let abrEnabledActive = abrToggle.checked;

        let isLoading = false;
        const keysPressed = new Set();

        abrToggle.addEventListener('change', () => {

        });


        // Handle keyboard events
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 's', 'a', 'd', ' ', 'shift'].includes(key)) {
                event.preventDefault();
                keysPressed.add(key);
            }
        });

        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            keysPressed.delete(key);
        });

        function update() {
            requestAnimationFrame(update);
            if (isLoading || keysPressed.size === 0) return;

            let updated = false;
            const rad = angle * Math.PI / 180;
            const cosA = Math.cos(rad);
            const sinA = Math.sin(rad);

            // Rotations
            if (keysPressed.has('arrowup')) { elevation = Math.min(90, elevation + rotStep); updated = true; }
            if (keysPressed.has('arrowdown')) { elevation = Math.max(-90, elevation - rotStep); updated = true; }
            if (keysPressed.has('arrowleft')) { angle = (angle - rotStep + 360) % 360; updated = true; }
            if (keysPressed.has('arrowright')) { angle = (angle + rotStep) % 360; updated = true; }

            // Translations
            if (keysPressed.has('w')) { x += posStep * sinA; z += posStep * cosA; updated = true; }
            if (keysPressed.has('s')) { x -= posStep * sinA; z -= posStep * cosA; updated = true; }
            if (keysPressed.has('a')) { x -= posStep * cosA; z += posStep * sinA; updated = true; }
            if (keysPressed.has('d')) { x += posStep * cosA; z -= posStep * sinA; updated = true; }
            if (keysPressed.has('shift')) { y += posStep; updated = true; }
            if (keysPressed.has(' ')) { y -= posStep; updated = true; }

            if (updated) {
                positionDisplay.textContent = `Angle: ${angle.toFixed(0)}°, Elevation: ${elevation.toFixed(0)}°, X: ${x.toFixed(1)}, Y: ${y.toFixed(1)}, Z: ${z.toFixed(1)}`;
                sendPosition();
            }
        }


        function applyConfig() {
            const [w, h] = resolutionSelect.value.split('x').map(Number);
            width = w;
            height = h;

            // Read camera + movement params
            fx = parseFloat(document.getElementById('fx').value);
            fy = parseFloat(document.getElementById('fy').value);
            cx = parseFloat(document.getElementById('cx').value);
            cy = parseFloat(document.getElementById('cy').value);
            rotStep = parseFloat(document.getElementById('rot-step').value);
            posStep = parseFloat(document.getElementById('pos-step').value);

            // Commit ABR state from the checkbox
            abrEnabledActive = abrToggle.checked;
            abr = ABRFactory.create(abrAlgoSelect.value, resolutionSelect)

            cx = width / 2; cy = height / 2;
            document.getElementById('cx').value = cx;
            document.getElementById('cy').value = cy;

            sendPosition();
        }

        function toggleSidebar() {
            sidebar.classList.toggle('collapsed');
        }

        function sendPosition() {
            isLoading = true;

            const abrEnabled = abrToggle.checked;
            let profile = 0;
            if (abrEnabled) {
                profile = abr.pickProfile(width, height);   // decide for this request
                abr.startRequest(profile, width, height);   // timestamp the request
            }

            const tFetchStart = performance.now();

            fetch('/render', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    angle, elevation, x, y, z, fx, fy, cx, cy, width, height, profile
                }),
            })
                .then(async (response) => {
                    // Read headers *before* consuming the body
                    const contentLength = Number(response.headers.get('Content-Length') || 0);
                    const renderHeader = response.headers.get('X-Render-Time-Ms');
                    const renderMs = renderHeader != null ? parseFloat(renderHeader) : NaN;

                    // Consume the body
                    const blob = await response.blob();

                    // Provide both header data + blob downstream
                    return { blob, contentLength, renderMs };
                })
                .then(({ blob, contentLength, renderMs }) => {
                    const imgUrl = URL.createObjectURL(blob);
                    const img = new Image();

                    img.onload = () => {
                        const displayW = Math.round(width);
                        const displayH = Math.round(height);

                        const rx = img.naturalWidth;
                        const ry = img.naturalHeight;

                        const scale = window.devicePixelRatio || 1;
                        const canvas = document.createElement('canvas');
                        canvas.width = displayW * scale;
                        canvas.height = displayH * scale;
                        canvas.style.width = displayW + 'px';
                        canvas.style.height = displayH + 'px';

                        const ctx = canvas.getContext('2d', { alpha: false });
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.scale(scale, scale);

                        ctx.drawImage(img, 0, 0, rx, ry, 0, 0, displayW, displayH);

                        objectViewer.innerHTML = '';
                        objectViewer.appendChild(canvas);

                        isLoading = false;

                        if (abrEnabled) {
                            // Prefer header Content-Length, fallback to blob.size if needed
                            const bytes = contentLength || blob.size || 0;

                            // Pass server render time (ms) as optional 4th arg.
                            // Your ABR can read it if implemented; otherwise it’s ignored.
                            abr.endRequest(bytes, rx, ry, renderMs);
                        }

                        if (!Number.isNaN(renderMs)) {
                            const el = document.getElementById('render-ms');
                            if (el) el.textContent = renderMs.toFixed(2);
                        }

                        URL.revokeObjectURL(imgUrl);
                    };

                    img.onerror = () => {
                        objectViewer.innerHTML = '<p>Error loading image</p>';
                        isLoading = false;
                        if (abrEnabled) abr.endRequest(0);
                        URL.revokeObjectURL(imgUrl);
                    };

                    img.src = imgUrl;
                })
                .catch(error => {
                    console.error('Error:', error);
                    objectViewer.innerHTML = '<p>Error loading image</p>';
                    isLoading = false;
                    if (abrEnabled) abr.endRequest(0);
                });
        }


        function updateImage() {
            sendPosition();
        }

        // Load initial image and start the loop
        updateImage();
        update();






    </script>
</body>

</html>